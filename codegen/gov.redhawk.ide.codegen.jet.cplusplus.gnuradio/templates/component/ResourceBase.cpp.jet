<%
/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file 
 * distributed with this source distribution.
 * 
 * This file is part of GNUHAWK.
 * 
 * GNUHAWK is free software: you can redistribute it and/or modify is under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any later 
 * version.
 * 
 * GNUHAWK is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with 
 * this program.  If not, see http://www.gnu.org/licenses/.
 */

%>
<%@ jet package="gov.redhawk.ide.codegen.jet.cplusplus.gnuradio.template.component"
imports="gov.redhawk.ide.codegen.CodegenUtil
gov.redhawk.ide.codegen.IPortTemplateDesc 
gov.redhawk.ide.codegen.IScaPortCodegenTemplate
gov.redhawk.ide.codegen.ImplementationSettings
gov.redhawk.ide.codegen.PortRepToGeneratorMap
gov.redhawk.ide.codegen.Property
gov.redhawk.ide.codegen.cplusplus.CppHelper
gov.redhawk.ide.codegen.jet.TemplateParameter
gov.redhawk.ide.codegen.jet.cplusplus.CplusplusJetGeneratorPlugin
gov.redhawk.ide.codegen.jet.cplusplus.CppProperties
gov.redhawk.ide.codegen.jet.cplusplus.ports.PropertyChangeEventPortTemplate
gov.redhawk.ide.codegen.jet.cplusplus.ports.MessagingPortTemplate
gov.redhawk.ide.codegen.jet.cplusplus.gnuradio.PortTemplate
gov.redhawk.model.sca.util.ModelUtil
gov.redhawk.ide.idl.IdlUtil
gov.redhawk.ide.idl.Interface
gov.redhawk.ide.idl.Operation
gov.redhawk.ide.RedhawkIdeActivator

java.util.regex.Pattern
java.util.regex.Matcher
java.util.Arrays
java.util.HashMap
java.util.List
java.util.Map
java.util.Date

mil.jpeojtrs.sca.scd.Ports
mil.jpeojtrs.sca.scd.Provides
mil.jpeojtrs.sca.scd.SupportsInterface
mil.jpeojtrs.sca.scd.Uses
mil.jpeojtrs.sca.spd.Implementation
mil.jpeojtrs.sca.spd.SoftPkg

org.eclipse.core.runtime.CoreException
org.eclipse.core.runtime.IPath
org.eclipse.core.runtime.IStatus
org.eclipse.core.runtime.Status
org.eclipse.core.runtime.Platform
org.eclipse.core.runtime.IProduct
org.eclipse.emf.common.util.EList"

class="ResourceBaseCppTemplate"
skeleton="../generator.skeleton2"
%>
<%
    TemplateParameter templ = (TemplateParameter) argument;
    ImplementationSettings implSettings = templ.getImplSettings();
    Implementation impl = templ.getImpl();
    SoftPkg softPkg = (SoftPkg) impl.eContainer();
    String PREFIX = gov.redhawk.ide.codegen.util.CodegenFileHelper.getPreferredFilePrefix(softPkg, implSettings);
    List<CppProperties.Property> properties = CppProperties.getProperties(softPkg);
    Ports ports = softPkg.getDescriptor().getComponent().getComponentFeatures().getPorts();
    EList<Provides> provides = ports.getProvides();
    EList<Uses> uses = ports.getUses();
    List<IPath> search_paths = Arrays.asList(RedhawkIdeActivator.getDefault().getDefaultIdlIncludePath());
    TemplateParameter portTempl = new TemplateParameter(impl, implSettings, search_paths);
    boolean autoStart = false;
    Date date = new Date(System.currentTimeMillis());
    for (Property tempProp : implSettings.getProperties()) {
        if ("auto_start".equals(tempProp.getId())) {
            if (Boolean.parseBoolean(tempProp.getValue())) {
                autoStart = true;
                break;
            }
        }
    }
    
    HashMap<String, IScaPortCodegenTemplate> portMap = new HashMap<String, IScaPortCodegenTemplate>();
    for (PortRepToGeneratorMap p : implSettings.getPortGenerators()) {
        try {
            IPortTemplateDesc template = CodegenUtil.getPortTemplate(p.getGenerator(), null);
            if (template != null) {
                portMap.put(p.getRepId(), template.getTemplate());
            }
        } catch (CoreException e) {
            // TODO What to do here! Throw the exception and not generate anything?
        }
    }
    String deviceType = "";
    boolean aggregateDevice = false;

    // TODO: Refactor this long block of code (and other similar blocks) into one handy place that can just give you an enum
    final List<SupportsInterface> supportedInterfaces = softPkg.getDescriptor().getComponent().getComponentFeatures().getSupportsInterface();
    for (SupportsInterface inter : supportedInterfaces) {
        if (inter.getRepId().equals("IDL:CF/Device:1.0")) {
            deviceType = "";
            break;
        }
    }

    for (SupportsInterface inter : supportedInterfaces) {
        if (inter.getRepId().equals("IDL:CF/LoadableDevice:1.0")) {
            deviceType = "Loadable"; 
            break;
        }
    }

    for (SupportsInterface inter : supportedInterfaces) {
        if (inter.getRepId().equals("IDL:CF/ExecutableDevice:1.0")) {
            deviceType = "Executable"; 
            break;
        }
    }

    for (SupportsInterface inter : supportedInterfaces) {
        if (inter.getRepId().equals("IDL:CF/AggregateDevice:1.0")) {
            aggregateDevice = true;
            break;
        }
    }

    Pattern p = Pattern.compile("/(.*):");
    boolean containsBULKIO = false;
    String outputType = "";         // maps to bulkio for i.e BULKIO_dataUshort_Out_i Ushort
    String outputRaw = "";          // maps to C type defined in port_impl.h UInt16
    for (Uses entry : uses) {
        String intName = entry.getRepID();

        if (intName.contains("BULKIO")) {
	   Matcher m = p.matcher(intName);
	   String iname="";	
	   if ( m.find() ) {
	   	iname = m.group(1);
           }
	   
            containsBULKIO = true;
            if (iname.equals("dataFloat")) {
                outputType = "Float";
                outputRaw = "Float";
            } else if (iname.equals("dataOctet")) {
                outputType = "Octet";
                outputRaw = "UInt8";
            } else if (iname.equals("dataChar")) {
                outputType = "Char";
                outputRaw = "Char";
            } else if (iname.equals("dataUshort")) {
                outputType = "Ushort";
                outputRaw = "UInt16";
            } else if (iname.equals("dataShort")) {
                outputType = "Short";
                outputRaw = "Int16";
            } else if (iname.equals("dataLong")) {
                outputType = "Long";
                  outputRaw = "Int32";
            } else if (iname.equals("dataLongLong")) {
                outputType = "LongLong";
                outputRaw = "Int64";
            } else if (iname.equals("dataUlong")) {
                outputType = "Ulong";
                  outputRaw = "UInt32";
            } else if (iname.equals("dataUlonglong")) {
                outputType = "Ulonglong";
                outputRaw = "UInt64";
            } else if (iname.equals("dataDouble")) {
                outputType = "Double";
                outputRaw = "Double";
            }
        }
    }
    String inputType = "";         // maps to bulkio for i.e BULKIO_dataUlong_In_i Ulong
    String inputRaw = "";          // maps to C type defined in port_impl.h UInt32
    for (Provides entry : provides) {
        String intName = entry.getRepID();
        if (intName.contains("BULKIO")) {
           containsBULKIO = true;
	   Matcher m = p.matcher(intName);
	   String iname="";	
	   if ( m.find() ) {
	   	iname = m.group(1);
           }

           //System.out.println("INT:" + intName + " iname:" + iname );
            if (iname.equals("dataFloat")) {
                inputType = "Float";
                inputRaw = "Float";
            } else if (iname.equals("dataOctet")) {
                inputType = "Octet";
                inputRaw = "UInt8";
            } else if (iname.equals("dataChar")) {
                inputType = "Char";
                inputRaw = "Char";
            } else if (iname.equals("dataUshort")) {
                inputType = "Ushort";
                   inputRaw = "UInt16";
            } else if (iname.equals("dataShort")) {
                inputType = "Short";
                  inputRaw = "Int16";
            } else if (iname.equals("dataLong")) {
                inputType = "Long";
                inputRaw = "Int32";
            } else if (iname.equals("dataLongLong")) {
                inputType = "LongLong";
                inputRaw = "Int64";
            } else if (iname.equals("dataUlong")) {
                inputType = "Ulong";
                inputRaw = "UInt32";
            } else if (iname.equals("dataUlonglong")) {
                inputType = "Ulonglong";
                inputRaw = "UInt64";
            } else if (iname.equals("dataDouble")) {
                inputType = "Double";
                inputRaw = "Double";
            }
        }
    }
    
    
    /**
      Determine Type of GnuRadio block we are patterning.
    */
	String blockType = "";
    for (Property tempProp : implSettings.getProperties()) {
        if ("pattern_gr_block".equals(tempProp.getId())) {
            if (Boolean.parseBoolean(tempProp.getValue())) {
            	blockType = "GR_Block";
                break;
            }
        }
        if ("pattern_gr_sync_block".equals(tempProp.getId())) {
            if (Boolean.parseBoolean(tempProp.getValue())) {
            	blockType = "GR_Sync_Block";
                break;
            }
        }
        if ("pattern_gr_sync_decimator".equals(tempProp.getId())) {
            if (Boolean.parseBoolean(tempProp.getValue())) {
            	blockType = "GR_Sync_Decimator";
                break;
            }
        }
        if ("pattern_gr_sync_interpolator".equals(tempProp.getId())) {
            if (Boolean.parseBoolean(tempProp.getValue())) {
            	blockType = "GR_Sync_Interpolator";
                break;
            }
        }
        
    }
    
%>
/*
 * This file is protected by Copyright. Please refer to the COPYRIGHT file 
 * distributed with this source distribution.
 * 
 * This file is part of GNUHAWK.
 * 
 * GNUHAWK is free software: you can redistribute it and/or modify is under the 
 * terms of the GNU General Public License as published by the Free Software 
 * Foundation, either version 3 of the License, or (at your option) any later 
 * version.
 * 
 * GNUHAWK is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more 
 * details.
 * 
 * You should have received a copy of the GNU General Public License along with 
 * this program.  If not, see http://www.gnu.org/licenses/.
 */

#include "<%=PREFIX%>_base.h"

/*******************************************************************************************

    AUTO-GENERATED CODE. DO NOT MODIFY
    
 	Source: <%=ModelUtil.getSpdFileName(softPkg)%>
<%
	String[] output;
	IProduct product = Platform.getProduct();
	if (product != null) {
		output = product.getProperty("aboutText").split("\n");
%>
 	<%=output[0]%>
 	<%=output[1]%>
 	<%=output[2]%>
<%
	}
%>

*******************************************************************************************/

//
//  Allow for logging 
// 
PREPARE_LOGGING(<%=PREFIX%>_base);


inline static unsigned int
round_up (unsigned int n, unsigned int multiple)
{
  return ((n + multiple - 1) / multiple) * multiple;
}

inline static unsigned int
round_down (unsigned int n, unsigned int multiple)
{
  return (n / multiple) * multiple;
}


/******************************************************************************************

    The following class functions are for the base class for the component class. To
    customize any of these functions, do not modify them here. Instead, overload them
    on the child class

******************************************************************************************/

<%
  if (!templ.isDevice()) {
%> 
<%=PREFIX%>_base::<%=PREFIX%>_base(const char *uuid, const char *label) :
 GnuHawkBlock(uuid, label), 
 serviceThread(0), 
 noutput_items(0),
<% if ( !inputType.equals("") ) { %>
 _sriListener(*this),
<% } %> 
 _maintainTimeStamp(false),
 _throttle(false)
{
    construct();
}
<%
    } else {
%>
<%=PREFIX%>_base::<%=PREFIX%>_base(char *devMgr_ior, char *id, char *lbl, char *sftwrPrfl) :
          <%=deviceType%>Device_impl (devMgr_ior, id, lbl, sftwrPrfl) <%
        if (aggregateDevice) {
%>, AggregateDevice_impl ()<%
        }
%>, serviceThread(0){
    construct();
}

<%=PREFIX%>_base::<%=PREFIX%>_base(char *devMgr_ior, char *id, char *lbl, char *sftwrPrfl, char *compDev) :
          <%=deviceType%>Device_impl (devMgr_ior, id, lbl, sftwrPrfl, compDev) <%
        if (aggregateDevice) {
%>, AggregateDevice_impl ()<%
        }
%>, serviceThread(0){
    construct();
}

<%=PREFIX%>_base::<%=PREFIX%>_base(char *devMgr_ior, char *id, char *lbl, char *sftwrPrfl, CF::Properties capacities) :
          <%=deviceType%>Device_impl (devMgr_ior, id, lbl, sftwrPrfl) <%
        if (aggregateDevice) {
%>, AggregateDevice_impl ()<%
        }
%>, serviceThread(0){
    construct();
}

<%=PREFIX%>_base::<%=PREFIX%>_base(char *devMgr_ior, char *id, char *lbl, char *sftwrPrfl, CF::Properties capacities, char *compDev) :
          <%=deviceType%>Device_impl (devMgr_ior, id, lbl, sftwrPrfl, compDev) <%
        if (aggregateDevice) {
%>, AggregateDevice_impl ()<%
        }
%>, serviceThread(0)
{
    construct();
}
<%}%>

void <%=PREFIX%>_base::construct()
{
    Resource_impl::_started = false;
    loadProperties();
    serviceThread = 0;
<% if ( !outputType.equals("") ) { %>
    sentEOS = false;
<% } %>   
<%
    if (provides.size() > 0) {
%>
    inputPortOrder.resize(0);;
<%
    }
    if (uses.size() > 0) {
%>
    outputPortOrder.resize(0);
<%
    }
%>

<% if ( inputType.equals("") && !outputType.equals("") ) { %>
   setThrottle(true);
<% } %>
    
    PortableServer::ObjectId_var oid;
<%
    for (Provides pro : provides) {
        String entry = pro.getRepID();
        IScaPortCodegenTemplate gen = portMap.get(entry);
        portTempl.setPortRepId(entry);
        portTempl.setPortName(pro.getProvidesName());
        portTempl.setProvidesPort(true);
        portTempl.setGenSupport(false);
        portTempl.setGenClassDef(false);
        portTempl.setGenClassImpl(false);
        String inst = null;
        if (MessagingPortTemplate.MESSAGECHANNEL_REPID.equals(entry)) {
            inst = new MessagingPortTemplate().generateClassInstantiator(entry, true, softPkg, implSettings, portTempl, CodegenUtil.CPP);
            inst += "(\""+pro.getProvidesName()+"\")";
        } else if (gen != null) {
            inst = gen.generateClassInstantiator(entry, true, softPkg, implSettings, portTempl, CodegenUtil.CPP);
        } else {
            inst = new PortTemplate().generateClassInstantiator(entry, true, softPkg, implSettings, portTempl, CodegenUtil.CPP);
        }
%>
    <%=pro.getProvidesName()%> = new <%=inst.trim()%>;
    oid = ossie::corba::RootPOA()->activate_object(<%=pro.getProvidesName()%>);
<%
    }
    for (Uses use : uses) {
        String entry = use.getRepID();
        IScaPortCodegenTemplate gen = portMap.get(entry);
        portTempl.setPortRepId(entry);
        portTempl.setPortName(use.getUsesName());
        portTempl.setProvidesPort(false);
        portTempl.setGenSupport(false);
        portTempl.setGenClassDef(false);
        portTempl.setGenClassImpl(false);
        String inst = null;
        // Loop over provides ports to see if there is a matching interface and port name for the current uses port
        // If so, ignore the uses port
        // This is to support bi-directional ports
        boolean foundMatchingProvides = false;
        for (Provides pro : provides) {
            String entryProvides = pro.getRepID();
            if (entry.equals(entryProvides) && use.getUsesName().equals(pro.getProvidesName())) {
                foundMatchingProvides = true;
                break;
            }
        }
        if (foundMatchingProvides == false){
            if (PropertyChangeEventPortTemplate.EVENTCHANNEL_REPID.equals(entry) 
                    && PropertyChangeEventPortTemplate.EVENTCHANNEL_NAME.equals(use.getUsesName())) {
                inst = new PropertyChangeEventPortTemplate().generateClassInstantiator(entry, false, softPkg, implSettings, portTempl, CodegenUtil.CPP);
                inst += "(\""+use.getUsesName()+"\")";
            } else if (MessagingPortTemplate.MESSAGECHANNEL_REPID.equals(entry)) {
        
                inst = new MessagingPortTemplate().generateClassInstantiator(entry, false, softPkg, implSettings, portTempl, CodegenUtil.CPP);
                inst += "(\""+use.getUsesName()+"\")";
            
            } else if (gen != null) {
                inst = gen.generateClassInstantiator(entry, false, softPkg, implSettings, portTempl, CodegenUtil.CPP);
            } else {
                inst = new PortTemplate().generateClassInstantiator(entry, false, softPkg, implSettings, portTempl, CodegenUtil.CPP);
            }
%>
    <%=use.getUsesName()%> = new <%=inst.trim()%>;
    oid = ossie::corba::RootPOA()->activate_object(<%=use.getUsesName()%>);
<%
    	    if (PropertyChangeEventPortTemplate.EVENTCHANNEL_REPID.equals(entry) 
                    && PropertyChangeEventPortTemplate.EVENTCHANNEL_NAME.equals(use.getUsesName())) {
	    		for (CppProperties.Property prop : properties) {
            		if (prop.getKinds().indexOf("event") != -1) {
%>
    <%=use.getUsesName()%>->registerProperty(this->_identifier, this->naming_service_name, this->getPropertyFromId("<%=CppHelper.escapeString(prop.getId())%>"));
<%
        		    }
    		    }
%>
    this->registerPropertyChangePort(<%=use.getUsesName()%>);
<%
    	    }
    	}  //if (foundMatchingProvides == false)
    }
    if ((provides.size() > 0) || (uses.size() > 0)) {
%>

<%
}
    for (Provides pro : provides) {
%>
    registerInPort(<%=pro.getProvidesName()%>);
    inputPortOrder.push_back("<%=pro.getProvidesName()%>");
<%
    }
    for (Uses use : uses) {
        String entry = use.getRepID();
        // Loop over provides ports to see if there is a matching interface and port name for the current uses port
        // If so, ignore the uses port
        // This is to support bi-directional ports
        boolean foundMatchingProvides = false;
        for (Provides pro : provides) {
            String entryProvides = pro.getRepID();
            if (entry.equals(entryProvides) && use.getUsesName().equals(pro.getProvidesName())) {
                foundMatchingProvides = true;
                break;
            }
        }
        if (foundMatchingProvides == false){
%>
    registerOutPort(<%=use.getUsesName()%>, <%=use.getUsesName()%>->_this());
    outputPortOrder.push_back("<%=use.getUsesName()%>");
    
<%
        }
    }
%>
}

/*******************************************************************************************
    Framework-level functions
    These functions are generally called by the framework to perform housekeeping.
*******************************************************************************************/
void <%=PREFIX%>_base::initialize() throw (CF::LifeCycle::InitializeError, CORBA::SystemException)
{
}

void <%=PREFIX%>_base::start() throw (CORBA::SystemException, CF::Resource::StartError)
{
    boost::mutex::scoped_lock lock(serviceThreadLock);
    if (serviceThread == 0) {
<%
    for (Provides pro : provides) {
        String entry = pro.getRepID();
        Interface intf = IdlUtil.getInstance().getInterface(search_paths, entry.split(":")[1], true); 
        if (intf == null) {
            throw new CoreException(new Status(IStatus.ERROR, CplusplusJetGeneratorPlugin.PLUGIN_ID, "Unable to find interface for " + entry));
        }
        
        String interfaceName = intf.getName();
        boolean hasPushPacketCall = false;
        boolean hasPushPacketXMLCall = false;
        boolean hasPushPacketFileCall = false;
        for (Operation op : intf.getOperations()) {
            int numParams = op.getParams().size();
            if ("pushPacket".equals(op.getName()) && "dataFile".equals(interfaceName)) {
                hasPushPacketFileCall = true;
            } else if ("pushPacket".equals(op.getName()) && (numParams == 4)) {
                hasPushPacketCall = true;
            } else if ("pushPacket".equals(op.getName()) && "dataXML".equals(interfaceName)) {
                hasPushPacketXMLCall = true;
            }
        }
        if (hasPushPacketCall || hasPushPacketXMLCall || hasPushPacketFileCall) {
%>
        if ( <%=pro.getProvidesName()%> ) <%=pro.getProvidesName()%>->unblock();
<%
        }
    }
%>
       	serviceThread = service_thread( this, 0.1);
        serviceThread->start();
    }
    
    if (!Resource_impl::started()) {
    	Resource_impl::start();
    }
}

void <%=PREFIX%>_base::stop() throw (CORBA::SystemException, CF::Resource::StopError)
{
<%
    for (Provides pro : provides) {
        String entry = pro.getRepID();
        Interface intf = IdlUtil.getInstance().getInterface(search_paths, entry.split(":")[1], true);
        if (intf == null) {
            throw new CoreException(new Status(IStatus.ERROR, CplusplusJetGeneratorPlugin.PLUGIN_ID, "Unable to find interface for " + entry));
        }
        
        String interfaceName = intf.getName();
        boolean hasPushPacketCall = false;
        boolean hasPushPacketXMLCall = false;
        boolean hasPushPacketFileCall = false;
        for (Operation op : intf.getOperations()) {
            int numParams = op.getParams().size();
            if ("pushPacket".equals(op.getName()) && (numParams == 4)) {
                hasPushPacketCall = true;
                break;
            } else if ("pushPacket".equals(op.getName()) && "dataXML".equals(interfaceName)) {
                hasPushPacketXMLCall = true;
                break;
            } else if ("pushPacket".equals(op.getName()) && "dataFile".equals(interfaceName)) {
                hasPushPacketFileCall = true;
                break;
            }
        }
        if (hasPushPacketCall || hasPushPacketXMLCall || hasPushPacketFileCall) {
%>
    if ( <%=pro.getProvidesName()%> ) <%=pro.getProvidesName()%>->block();
<%
        }
    }
%>

<% if (!inputType.equals("") ) { %> 
    {
      boost::mutex::scoped_lock lock(_sriMutex);
      _sriQueue.clear();
    }
<% } %>

    // release the child thread (if it exists)
    if (serviceThread != 0) {
      {
        boost::mutex::scoped_lock lock(serviceThreadLock);
        LOG_TRACE( <%=PREFIX%>_base, "Stopping Service Function" );
        serviceThread->stop();
      }

      if ( !serviceThread->release()) {
         throw CF::Resource::StopError(CF::CF_NOTSET, "Processing thread did not die");
      }

      boost::mutex::scoped_lock lock(serviceThreadLock);
      if ( serviceThread ) {
        delete serviceThread;
      }
    }
    serviceThread = 0;

    if (Resource_impl::started()) {
        Resource_impl::stop();
    }
    
    LOG_TRACE( <%=PREFIX%>_base, "COMPLETED STOP REQUEST" );
}

<%
    if ((uses.size() > 0) || (provides.size() > 0)) {
%>
CORBA::Object_ptr <%=PREFIX%>_base::getPort(const char* _id) throw (CORBA::SystemException, CF::PortSupplier::UnknownPort)
{

    std::map<std::string, Port_Provides_base_impl *>::iterator p_in = inPorts.find(std::string(_id));
    if (p_in != inPorts.end()) {

<%
        for (Provides pro : provides) {
            String entry = pro.getRepID();
            Interface intf = IdlUtil.getInstance().getInterface(search_paths, entry.split(":")[1], true); 
            if (intf == null) {
                throw new CoreException(new Status(IStatus.ERROR, CplusplusJetGeneratorPlugin.PLUGIN_ID, "Unable to find interface for " + entry));
            }
            String nameSpace = intf.getNameSpace();
            String interfaceName = intf.getName();
        	if (MessagingPortTemplate.MESSAGECHANNEL_REPID.equals(entry)) {
%>
        if (!strcmp(_id,"<%=pro.getProvidesName()%>")) {
            MessageConsumerPort *ptr = dynamic_cast<MessageConsumerPort *>(p_in->second);
            if (ptr) {
                return <%=nameSpace%>::<%=interfaceName%>::_duplicate(ptr->_this());
            }
        }
<%
        	} else {
%>
        if (!strcmp(_id,"<%=pro.getProvidesName()%>")) {
            <%=nameSpace%>_<%=interfaceName%>_In_i *ptr = dynamic_cast<<%=nameSpace%>_<%=interfaceName%>_In_i *>(p_in->second);
            if (ptr) {
                return <%=nameSpace%>::<%=interfaceName%>::_duplicate(ptr->_this());
            }
        }
<%
        	}
        }
%>
    }

    std::map<std::string, CF::Port_var>::iterator p_out = outPorts_var.find(std::string(_id));
    if (p_out != outPorts_var.end()) {
        return CF::Port::_duplicate(p_out->second);
    }

    throw (CF::PortSupplier::UnknownPort());
}
<%
    }
%>

void <%=PREFIX%>_base::releaseObject() throw (CORBA::SystemException, CF::LifeCycle::ReleaseError)
{
    // This function clears the component running condition so main shuts down everything
    try {
        stop();
    } catch (CF::Resource::StopError& ex) {
        // TODO - this should probably be logged instead of ignored
    }

    // deactivate ports
    releaseInPorts();
    releaseOutPorts();

<%
    for (Provides pro : provides) {
%>
    delete(<%=pro.getProvidesName()%>);
<%
    }
    for (Uses use : uses) {
        String entry = use.getRepID();
        // Loop over provides ports to see if there is a matching interface and port name for the current uses port
        // If so, ignore the uses port
        // This is to support bi-directional ports
        boolean foundMatchingProvides = false;
        for (Provides pro : provides) {
            String entryProvides = pro.getRepID();
            if (entry.equals(entryProvides) && use.getUsesName().equals(pro.getProvidesName())) {
                foundMatchingProvides = true;
                break;
            }
        }
        if (foundMatchingProvides == false){
%>
    delete(<%=use.getUsesName()%>);
<%
        }
    }
%>

    <%
    if (!templ.isDevice()) {
%> 
    Resource_impl::releaseObject();
    <%
    } else {
%>
    <%=deviceType%>Device_impl::releaseObject();
    <%
    }
%>
    LOG_TRACE( <%=PREFIX%>_base, "COMPLETED RELEASE OBJECT" );
}

void <%=PREFIX%>_base::loadProperties()
{
<%
    for (CppProperties.Property prop : properties) {
        if (prop.hasValue() && (prop instanceof CppProperties.SimpleSeqProperty)) {
%>
    // Set the sequence with its initial values
<%
            for(String v : ((CppProperties.SimpleSeqProperty)prop).getCppValues()) {
%>
    <%=prop.getCppName()%>.push_back(<%=v%>);
<%
            }
        } else if (prop instanceof CppProperties.StructSequenceProperty) {
%>            
        <%=prop.getCppName()%>.resize(<%=((CppProperties.StructSequenceProperty)prop).numberOfStructValues()%>);
<%
            Map<CppProperties.SimpleProperty, List<String>> myMap = ((CppProperties.StructSequenceProperty)prop).getValueMap(); 
            for (CppProperties.SimpleProperty simple : myMap.keySet()) {
                if (!myMap.get(simple).isEmpty()) {
                    int i = 0;
                    for (String val : myMap.get(simple)) {
%>
        <%=prop.getCppName()%>[<%=i%>].<%=simple.getCppName()%> = <%=val%>;
<%
                        i++;
                    }
                }
            }
        }
        
%>
    addProperty(<%=prop.getCppName()%>,
<%
        if (prop.hasValue()) {
%>
                <%=prop.getCppValue()%>, 
<%
        }
%>
               "<%=CppHelper.escapeString(prop.getId())%>",
<%
        if (prop.hasName()) {
%>
               "<%=CppHelper.escapeString(prop.getName())%>",
<%
        } else {
%>
               "",
<%
        }
%>
               "<%=CppHelper.escapeString(prop.getMode())%>",
               "<%=CppHelper.escapeString(prop.getUnits())%>",
               "<%=CppHelper.escapeString(prop.getAction())%>",
               "<%=CppHelper.escapeString(prop.getKinds())%>");

<%
    }
%>
}


<% if (!outputType.equals("") ) { %>  
uint32_t <%=PREFIX%>_base::getNOutputStreams() {
	return 0;
}
<% } %>

<% if (!outputType.equals("") || !inputType.equals("") ) { %>  
void <%=PREFIX%>_base::setupIOMappings( ) 
{
  int ninput_streams = 0;
  int noutput_streams = 0;
  std::vector<std::string>::iterator pname;
  std::string sid("");
<% if (!inputType.equals("") ) { %>  
  int inMode=RealMode;
<% } %>

  if ( !validGRBlock() ) return;

<% if (!inputType.equals("") ) { %>  
  ninput_streams  = gr_sptr->get_max_input_streams();
  gr_io_signature_sptr g_isig = gr_sptr->input_signature();
<% } %>
<% if (!outputType.equals("") ) { %>  
  noutput_streams = gr_sptr->get_max_output_streams();
  gr_io_signature_sptr g_osig = gr_sptr->output_signature();
<% } %>
  
  LOG_DEBUG( <%=PREFIX%>_base, "GNUHAWK IO MAPPINGS IN/OUT " << ninput_streams << "/" << noutput_streams );

  //
  // Someone reset the GR Block so we need to clean up old mappings if they exists
  // we need to reset the io signatures and check the vlens
  //
<% 
   if (!inputType.equals("") || !outputType.equals("") ) { 
%> 

<% 
   if (!inputType.equals("") && !outputType.equals("") ) { 
%> 
   if ( _istreams.size() > 0 || _ostreams.size() > 0 ) {
<% } %>

<% 
   if (!inputType.equals("") && outputType.equals("") ) { 
%> 
   if ( _istreams.size() > 0 ) {
<% } %>

<% 
   if (inputType.equals("") && !outputType.equals("") ) { 
%> 
   if ( _ostreams.size() > 0 ) {
<% } %>

<% 
   // create mapping for input Ports to istream definitions 
   if (!inputType.equals("") ) { 
%> 
    LOG_DEBUG(  <%=PREFIX%>_base, "RESET INPUT SIGNATURE SIZE:" << _istreams.size() );
    IStreamList::iterator istream;
    for ( int idx=0 ; istream != _istreams.end(); idx++, istream++ ) {
        // re-add existing stream definitons
      LOG_DEBUG(  <%=PREFIX%>_base, "ADD READ INDEX TO GNU RADIO BLOCK");
      if ( ninput_streams == -1 ) gr_sptr->add_read_index();

      // setup io signature 
      istream->associate( gr_sptr );
    }
<% } %>

<% 
   // create mapping for input Ports to istream definitions 
   if (!outputType.equals("") ) { 
%> 
    LOG_DEBUG(  <%=PREFIX%>_base, "RESET OUTPUT SIGNATURE SIZE:" << _ostreams.size() );
    OStreamList::iterator ostream;
    for ( int idx=0 ; ostream != _ostreams.end(); idx++, ostream++ ) {
        // need to evaluate new settings...???
        ostream->associate( gr_sptr );
    }
<% } %>

    return;
  }

<% } %>
    
<% 
   // create mapping for input Ports to istream definitions 
   if (!inputType.equals("") ) { 
%> 
   //
   // Setup mapping of RH port to GNU RADIO Block input streams
   // For version 1,  we are ignoring the GNU Radio input stream -1 case that allows multiple data 
   // streams over a single connection.  We are mapping a single RH Port to a single GNU Radio stream.
   // Stream Identifiers will  be pass along as they are received
   //
   LOG_TRACE( <%=PREFIX%>_base, "setupIOMappings INPUT PORTS: " << inPorts.size() );
   pname = inputPortOrder.begin();
   for( int i=0; pname != inputPortOrder.end(); pname++ ) {

       // grab ports based on their order in the scd.xml file
       RH_ProvidesPortMap::iterator p_in = inPorts.find(*pname);
       if ( p_in != inPorts.end() ) {
           BULKIO_data<%=inputType%>_In_i *port = dynamic_cast< BULKIO_data<%=inputType%>_In_i * >(p_in->second);
   	   int mode = inMode;
	   sid = "";

           // need to add read index to GNU Radio Block for processing streams when max_input == -1
       	   if ( ninput_streams == -1 ) gr_sptr->add_read_index();

	   // check if we received SRI during setup
	   BULKIO::StreamSRISequence_var sris = port->activeSRIs();
           if (  sris->length() > 0 ) {
               BULKIO::StreamSRI sri = sris[sris->length()-1];
               mode = sri.mode;
           }

	   _istreams.push_back( gr_istream< BULKIO_data<%=inputType%>_In_i > ( port, gr_sptr, i, mode, sid ));
	   LOG_DEBUG(  <%=PREFIX%>_base, "ADDING INPUT MAP IDX:" << i << " SID:" << sid );	
	   // increment port counter
	   i++;
       }
   } 

<% } %>

<% 
  // create mapping for output Ports to ostream definitions 
  if (!outputType.equals("") ) { 
%> 
   //
   // Setup mapping of RH port to GNU RADIO Block input streams
   // For version 1,  we are ignoring the GNU Radio output stream -1 case that allows multiple data 
   // streams over a single connection.  We are mapping a single RH Port to a single GNU Radio stream.
   //
   LOG_TRACE( <%=PREFIX%>_base, "setupIOMappings OutputPorts: " << outPorts.size() );
   pname = outputPortOrder.begin();
   for( int i=0; pname != outputPortOrder.end(); pname++ ) {

       // grab ports based on their order in the scd.xml file
       RH_UsesPortMap::iterator p_out = outPorts.find(*pname);
       if ( p_out != outPorts.end() ) {
           BULKIO_data<%=outputType%>_Out_i *port = dynamic_cast< BULKIO_data<%=outputType%>_Out_i * >(p_out->second);
	   BULKIO::StreamSRI sri = createOutputSRI( i );
	   int mode = sri.mode;
	   sid = sri.streamID;
	   _ostreams.push_back( gr_ostream< BULKIO_data<%=outputType%>_Out_i > ( port, gr_sptr, i, mode, sid ));
	   LOG_DEBUG(  <%=PREFIX%>_base, "ADDING OUTPUT MAP IDX:" << i << " SID:" << sid );	
	   _ostreams[i].setSRI(sri, i );
<% if (inputType.equals("") ) { %>
           _ostreams[i].pushSRI();
<% } %>
	   // increment port counter
	   i++;
       }
   }

<% } %>

}

<% } %>



<% if (!inputType.equals("") ) { %>

void <%=PREFIX%>_base::notifySRI( BULKIO_data<%=inputType%>_In_i *port, BULKIO::StreamSRI &sri ) {

  LOG_TRACE( <%=PREFIX%>_base, "START NotifySRI  port:stream " << port->getName() << "/" << sri.streamID);
  boost::mutex::scoped_lock lock(_sriMutex);
  _sriQueue.push_back( std::make_pair( port, sri ) );
  LOG_TRACE( <%=PREFIX%>_base, "END  NotifySRI  QUEUE " << _sriQueue.size() << " port:stream " << port->getName() << "/" << sri.streamID); 
  
}
 
void <%=PREFIX%>_base::processStreamIdChanges() {

  boost::mutex::scoped_lock lock(_sriMutex);

  LOG_TRACE( <%=PREFIX%>_base, "processStreamIDChanges QUEUE: " << _sriQueue.size()  );
  if (  _sriQueue.size() == 0 ) return;
  std::string sid("");

  if ( validGRBlock() ) {

    IStreamList::iterator istream;
    int idx=0;
    std::string sid("");
    int mode=0;
    SRIQueue::iterator item = _sriQueue.begin();
    
    for ( ; item != _sriQueue.end(); item++ ) {
       idx = 0;
       sid = "";
       mode= item->second.mode;
       sid = item->second.streamID;
       istream = _istreams.begin();
       for ( ; istream != _istreams.end(); idx++, istream++ ) {

	   if ( istream->port == item->first ) {
	       LOG_DEBUG(  <%=PREFIX%>_base,  "  SETTING IN_STREAM ID/STREAM_ID :" << idx << "/" << sid  );
	       istream->sri(true);
	       istream->spe(mode);

<% if (!outputType.equals("") ) { %>
	       LOG_DEBUG(  <%=PREFIX%>_base,  "  SETTING  OUT_STREAM ID/STREAM_ID :" << idx << "/" << sid  );
	       setOutputStreamSRI( idx, item->second );
<% } %>
           }
       }

   }

   _sriQueue.clear();
     
  }
  else {
 	LOG_WARN(  <%=PREFIX%>_base, " NEW STREAM ID, NO GNU RADIO BLOCK DEFINED, SRI QUEUE SIZE:" << _sriQueue.size() );
  }

}

<% } %>


<%
   if ( !outputType.equals("") ) {
%>
BULKIO::StreamSRI <%=PREFIX%>_base::createOutputSRI( int32_t idx)
{
  // for each output stream set the SRI context
  BULKIO::StreamSRI sri = BULKIO::StreamSRI();
  sri.hversion = 1;
  sri.xstart = 0.0;
  sri.xdelta = 1;
  sri.xunits = BULKIO::UNITS_TIME;
  sri.subsize = 0;
  sri.ystart = 0.0;
  sri.ydelta = 0.0;
  sri.yunits = BULKIO::UNITS_NONE;
  sri.mode = 0;
  std::ostringstream t;
  t << naming_service_name.c_str() << "_" << idx;
  std::string sid = t.str();
  sri.streamID = CORBA::string_dup(sid.c_str());
  
  return sri;
 
}
<% } %> 


<%
   if ( !outputType.equals("") ) {
%>
void <%=PREFIX%>_base::adjustOutputRate(BULKIO::StreamSRI &sri ) {

   if ( validGRBlock() ) {
      double ret=sri.xdelta*gr_sptr->relative_rate();
/**      
<% if ( blockType.equals("GR_Sync_Decimator") ) { %>
      ret = ret *gr_sptr->decimation();
<% } %>
<% if ( blockType.equals("GR_Sync_Interpolator") ) { %>
      ret = ret  / gr_sptr->interpolation();
<% } %>
**/
      LOG_TRACE(<%=PREFIX%>_base, "ADJUSTING SRI.XDELTA FROM/TO: " << sri.xdelta << "/" << ret );
      sri.xdelta = ret;

   }
   
}
<% } %> 

<%=PREFIX%>_base::TimeDuration <%=PREFIX%>_base::getTargetDuration() {

  TimeDuration  t_drate;;
  uint64_t samps=0;
  double   xdelta=1.0;
  double   trate=1.0;

<% if ( !outputType.equals("") ) { %>
  if ( _ostreams.size() > 0 ) {
    samps= _ostreams[0].nelems();
    xdelta= _ostreams[0].sri.xdelta;
  }
<% } %> 

  trate = samps*xdelta;
  uint64_t sec = (uint64_t)trunc(trate);
  uint64_t usec = (uint64_t)((trate-sec)*1e6);
  t_drate = boost::posix_time::seconds(sec) + 
            boost::posix_time::microseconds(usec);
  LOG_TRACE( <%=PREFIX%>_base, " SEC/USEC " << sec << "/"  << usec << "\n"  <<
	     " target_duration " << t_drate );
  return t_drate;
}

<%=PREFIX%>_base::TimeDuration <%=PREFIX%>_base::calcThrottle( TimeMark &start_time,
                                             TimeMark &end_time ) {

  TimeDuration delta;
  TimeDuration target_duration = getTargetDuration();

  if ( start_time.is_not_a_date_time() == false ) {
    TimeDuration s_dtime= end_time - start_time;
    delta = target_duration - s_dtime;
    delta /= 4;
    LOG_TRACE( <%=PREFIX%>_base, " s_time/t_dime " << s_dtime << "/" << target_duration << "\n"  <<
	      " delta " << delta );
  }
  return delta;
}


<%
    /////////////////////////////////////
    // BEGIN DATA ANALYZER PATTERN
    /////////////////////////////////////
  if ( !inputType.equals("") && outputType.equals("") ) {
%>

/**
  DATA ANALYZER TEMPLATE Service Function for GR_BLOCK PATTERN
*/

template < typename IN_PORT_TYPE > int <%=PREFIX%>_base::_analyzerServiceFunction( typename  std::vector< gr_istream< IN_PORT_TYPE > > &istreams ) {

  typedef typename std::vector< gr_istream< IN_PORT_TYPE > > _IStreamList;

  boost::mutex::scoped_lock lock(serviceThreadLock);

  if ( validGRBlock() == false ) {
    
    // create our processing block
    createBlock();

    LOG_DEBUG(  <%=PREFIX%>_base, " FINISHED BUILDING  GNU RADIO BLOCK");
  }
   
  // process any Stream ID changes this could affect number of io streams
  processStreamIdChanges();
    
  if ( !validGRBlock() || istreams.size() == 0 ) {
    LOG_WARN(<%=PREFIX%>_base, "NO STREAMS ATTACHED TO BLOCK..." );
    return NOOP;
  }

  // resize data vectors for passing data to GR_BLOCK object
  _input_ready.resize( istreams.size() );
  _ninput_items_required.resize( istreams.size());
  _ninput_items.resize( istreams.size());
  _input_items.resize(istreams.size());
  _output_items.resize(0);
  
  //
  // RESOLVE: need to look at forecast strategy, 
  //    1)  see how many read items are necessary for N number of outputs
  //    2)  read input data and see how much output we can produce
  //
  
  //
  // Grab available data from input streams
  //
  typename _IStreamList::iterator istream = istreams.begin();
  int nitems=0;
  for ( int idx=0 ; istream != istreams.end() && serviceThread->threadRunning() ; idx++, istream++ ) {
    // note this a blocking read that can cause deadlocks
    nitems = istream->read();
    
    if ( istream->overrun() ) {
        LOG_WARN( <%=PREFIX%>_base, " NOT KEEPING UP WITH STREAM ID:" << istream->streamID );
    }
    
    // RESOLVE issue when SRI changes that could affect the GNU Radio BLOCK
    if ( istream->sriChanged() ) {
      LOG_DEBUG( <%=PREFIX%>_base, "SRI CHANGED, STREAMD IDX/ID: " 
               << idx << "/" << istream->pkt->streamID );
    }
  }

  LOG_TRACE( <%=PREFIX%>_base, "READ NITEMS: "  << nitems );
  if ( nitems <= 0 && !_istreams[0].eos() ) return NOOP;

  bool exitServiceFunction = false;
  bool eos = false;
  int  nout = 0;
  while ( nout > -1 && !exitServiceFunction && serviceThread->threadRunning() ) {

    eos = false;
    nout = _forecastAndProcess( eos, istreams );
    if ( nout > -1  ) {
      // we chunked on data so move read pointer..
      istream = istreams.begin();
      for ( ; istream != istreams.end(); istream++ ) {

	int idx=std::distance( istreams.begin(), istream );
	// if we processed data for this stream
	if ( _input_ready[idx] ) {
	  size_t nitems = 0;
	  try {
	    nitems = gr_sptr->nitems_read( idx );
	  }
	  catch(...){}
      
	  if ( nitems > istream->nitems() ) {
	       LOG_WARN( <%=PREFIX%>_base,  "WORK CONSUMED MORE DATA THAN AVAILABLE,  READ/AVAILABLE " << nitems << "/" << istream->nitems() );
               nitems = istream->nitems();
	  }
	  istream->consume( nitems );
          LOG_TRACE( <%=PREFIX%>_base, " CONSUME READ DATA  ITEMS/REMAIN " << nitems << "/" << istream->nitems());
	}

      }
      gr_sptr->reset_read_index();
    }

    // check for not enough data return
    if ( nout == -1 ) {

      // check for  end of stream
      istream = istreams.begin();
      for ( ; istream != istreams.end() ; istream++) if ( istream->eos() ) eos=true;

      if ( eos ) {
        LOG_TRACE( <%=PREFIX%>_base, " DATA NOT READY, EOS:" << eos );
	_forecastAndProcess( eos, istreams );
      }

      exitServiceFunction = true;
    }

  }

  if ( eos ) {

    istream = istreams.begin();
    for ( ; istream != istreams.end() ; istream++) {
      int idx=std::distance( istreams.begin(), istream );
      LOG_TRACE( <%=PREFIX%>_base, " CLOSING INPUT STREAM IDX:" << idx );
      istream->close();
    }
  }

  //
  // set the read pointers of the GNU Radio Block to start at the beginning of the 
  // supplied buffers
  //
  gr_sptr->reset_read_index();

  LOG_TRACE( <%=PREFIX%>_base, " END OF ANALYZER SERVICE FUNCTION....." << noutput_items );

  if ( nout == -1 && eos == false )
    return NOOP; 
  else
    return NORMAL;
}


template <  typename IN_PORT_TYPE > int <%=PREFIX%>_base::_forecastAndProcess( bool &eos, typename  std::vector< gr_istream< IN_PORT_TYPE > > &istreams )
{
  typedef typename std::vector< gr_istream< IN_PORT_TYPE > >   _IStreamList;

  typename _IStreamList::iterator istream = istreams.begin();
  int nout = 0;
  bool dataReady = false;
  if ( !eos ) {
    uint64_t max_items_avail = 0;
    for ( int idx=0 ; istream != istreams.end() && serviceThread->threadRunning() ; idx++, istream++ ) {
      LOG_TRACE(  <%=PREFIX%>_base, "GET MAX ITEMS: STREAM:"<< idx << " NITEMS/SCALARS:" << istream->nitems() << "/" << istream->_data.size() );
      max_items_avail = std::max( istream->nitems(), max_items_avail );
    }

    //
    // calc number of output items to produce
    //
    noutput_items = (int) (max_items_avail * gr_sptr->relative_rate ());
    noutput_items = round_down (noutput_items, gr_sptr->output_multiple ());

    if ( noutput_items <= 0  ) {
       LOG_TRACE( <%=PREFIX%>_base, "DATA CHECK - MAX ITEMS  NOUTPUT/MAX_ITEMS:" <<   noutput_items << "/" << max_items_avail);
       return -1;
    }

    if ( gr_sptr->fixed_rate() ) {
      istream = istreams.begin();
      for ( int i=0; istream != istreams.end(); i++, istream++ ) {
	if ( gr_sptr->fixed_rate() ) {
	  int t_noutput_items = gr_sptr->fixed_rate_ninput_to_noutput( istream->nitems() );
	  if ( gr_sptr->output_multiple_set() ) {
	    t_noutput_items = round_up(t_noutput_items, gr_sptr->output_multiple());
	  }
	  if ( t_noutput_items > 0 ) {
	    if ( noutput_items == 0 ) noutput_items = t_noutput_items;
	    if ( t_noutput_items <= noutput_items ) noutput_items = t_noutput_items;
	  }
	}
      }
      LOG_TRACE( <%=PREFIX%>_base, " FIXED FORECAST NOUTPUT/output_multiple == " << noutput_items  << "/" << gr_sptr->output_multiple());
    }

    //
    // ask the block how much input they need to produce noutput_items...
    // if enough data is available to process then set the dataReady flag
    //
    int32_t  outMultiple = gr_sptr->output_multiple();
    while ( !dataReady && noutput_items >= outMultiple  ) {

      //
      // ask the block how much input they need to produce noutput_items...
      //
      gr_sptr->forecast(noutput_items, _ninput_items_required);

      LOG_TRACE( <%=PREFIX%>_base, "--> FORECAST IN/OUT " << _ninput_items_required[0]  << "/" << noutput_items  );

      istream = istreams.begin();
      uint32_t dr_cnt=0;
      for ( int idx=0 ; noutput_items > 0 && istream != istreams.end(); idx++, istream++ ) {
	// check if buffer has enough elements
	_input_ready[idx] = false;
	if ( istream->nitems() >= (uint64_t)_ninput_items_required[idx] ) {
	  _input_ready[idx] = true;
	  dr_cnt++;
	}
	LOG_TRACE( <%=PREFIX%>_base, "ISTREAM DATACHECK NELMS/NITEMS/REQ/READY:" <<   istream->nelems() << "/" << istream->nitems() << "/" << _ninput_items_required[idx] << "/" << _input_ready[idx]);
      }
    
      if ( dr_cnt < istreams.size() ) {
        if ( outMultiple > 1 )
       	  noutput_items -= outMultiple;
        else
          noutput_items /= 2;
      }
      else {
        dataReady = true;
      }
      LOG_TRACE( <%=PREFIX%>_base, " TRIM FORECAST NOUTPUT/READY " << noutput_items << "/" << dataReady );
    }

    // check if data is ready...
    if ( !dataReady ) {
      LOG_TRACE( <%=PREFIX%>_base, "DATA CHECK - NOT ENOUGH DATA  AVAIL/REQ:" <<   _istreams[0].nitems() << "/" << _ninput_items_required[0] );
      return -1;	 
    }


    // reset looping variables
    int  ritems = 0;
    int  nitems = 0;

    // reset caching vectors
    _output_items.clear();
    _input_items.clear();
    _ninput_items.clear();
    istream = istreams.begin();
    for ( int idx=0 ; istream != istreams.end(); idx++, istream++ ) {

      // check if the stream is ready
      if ( !_input_ready[idx] ) continue;
      
      // get number of items remaining
      try {
        ritems = gr_sptr->nitems_read( idx );
      }
      catch(...){
        // something bad has happened, we are missing an input stream
	LOG_ERROR( <%=PREFIX%>_base, "MISSING INPUT STREAM FOR GR BLOCK, STREAM ID:" <<   istream->streamID );
        return -2;
      } 
    
      nitems = istream->nitems() - ritems;
      LOG_TRACE( <%=PREFIX%>_base,  " ISTREAM: IDX:" << idx  << " ITEMS AVAIL/READ/REQ " << nitems << "/" 
		 << ritems << "/" << _ninput_items_required[idx] );
      if ( nitems >= _ninput_items_required[idx] && nitems > 0 ) {
	//remove eos checks ...if ( nitems < _ninput_items_required[idx] ) nitems=0;
        _ninput_items.push_back( nitems );
	_input_items.push_back( (const void *) (istream->read_pointer(ritems)) );
      }
    }

    nout=0;
    if ( _input_items.size() != 0 && serviceThread->threadRunning() ) {
      LOG_TRACE( <%=PREFIX%>_base, " CALLING WORK.....N_OUT:" << noutput_items << " N_IN:" << nitems << " ISTREAMS:" << _input_items.size() << " OSTREAMS:" << _output_items.size());
      nout = gr_sptr->general_work( noutput_items, _ninput_items, _input_items, _output_items);

       // sink/analyzer patterns do not return items, so consume_each is not called in Gnu Radio BLOCK
       if ( nout == 0 ) {
           gr_sptr->consume_each(nitems);
       }

      LOG_TRACE( <%=PREFIX%>_base, "RETURN  WORK ..... N_OUT:" << nout);
    }

    // check for stop condition from work method
    if ( nout < gr_block::WORK_DONE ) {
      LOG_WARN( <%=PREFIX%>_base, "WORK RETURNED STOP CONDITION..." << nout );
      nout=0;
      eos = true;
    }
  }

  return nout;
     
}


<%
   // End of Template for Data Analyzer Pattern 
  } 
%>

<%
    /////////////////////////////////////
    // BEGIN DATA TRANSFORMER PATTERN
    /////////////////////////////////////
   if ( !inputType.equals("") && !outputType.equals("") ) {
%>
template <  typename IN_PORT_TYPE, typename OUT_PORT_TYPE > int <%=PREFIX%>_base::_transformerServiceFunction( typename  std::vector< gr_istream< IN_PORT_TYPE > > &istreams ,
											typename  std::vector< gr_ostream< OUT_PORT_TYPE > > &ostreams  )
{
  typedef typename std::vector< gr_istream< IN_PORT_TYPE > >   _IStreamList;
  typedef typename std::vector< gr_ostream< OUT_PORT_TYPE > >  _OStreamList;

  boost::mutex::scoped_lock lock(serviceThreadLock);

  if ( validGRBlock() == false ) {

    // create our processing block, and setup  property notifiers
    createBlock();

    LOG_DEBUG( <%=PREFIX%>_base, " FINISHED BUILDING  GNU RADIO BLOCK");
  }
 
  //process any Stream ID changes this could affect number of io streams
  processStreamIdChanges();

  if ( !validGRBlock() || istreams.size() == 0 || ostreams.size() == 0  ) {
    LOG_WARN(<%=PREFIX%>_base, "NO STREAMS ATTACHED TO BLOCK..." );
    return NOOP;
  }

  _input_ready.resize( istreams.size() );
  _ninput_items_required.resize( istreams.size() );
  _ninput_items.resize( istreams.size() );
  _input_items.resize( istreams.size() );
  _output_items.resize( ostreams.size() );

  //
  // RESOLVE: need to look at forecast strategy, 
  //    1)  see how many read items are necessary for N number of outputs
  //    2)  read input data and see how much output we can produce
  //

  //
  // Grab available data from input streams
  //
  typename _OStreamList::iterator ostream;
  typename _IStreamList::iterator istream = istreams.begin();
  int nitems=0;
  for ( int idx=0 ; istream != istreams.end() && serviceThread->threadRunning() ; idx++, istream++ ) {
    // note this a blocking read that can cause deadlocks
    nitems = istream->read();
    
    if ( istream->overrun() ) {
      LOG_WARN( <%=PREFIX%>_base, " NOT KEEPING UP WITH STREAM ID:" << istream->streamID );
    }

    if ( istream->sriChanged() ) {
      // RESOLVE - need to look at how SRI changes can affect Gnu Radio BLOCK state
      LOG_DEBUG( <%=PREFIX%>_base, "SRI CHANGED, STREAMD IDX/ID: " 
               << idx << "/" << istream->pkt->streamID );
      setOutputStreamSRI( idx, istream->pkt->SRI );
    }

  }

  LOG_TRACE( <%=PREFIX%>_base, "READ NITEMS: "  << nitems );
  if ( nitems <= 0 && !_istreams[0].eos() ) return NOOP;

  bool exitServiceFunction = false;
  bool eos = false;
  int  nout = 0;
  while ( nout > -1 && !exitServiceFunction && serviceThread->threadRunning() ) {

    eos = false;
    nout = _forecastAndProcess( eos, istreams, ostreams );
    if ( nout > -1  ) {

      // we chunked on data so move read pointer..
      istream = istreams.begin();
      for ( ; istream != istreams.end(); istream++ ) {
	int idx=std::distance( istreams.begin(), istream );
	// if we processed data for this stream
	if ( _input_ready[idx] ) {
	  size_t nitems = 0;
	  try {
	    nitems = gr_sptr->nitems_read( idx );
	  }
	  catch(...){}
      
	  if ( nitems > istream->nitems() ) {
	       LOG_WARN( <%=PREFIX%>_base,  "WORK CONSUMED MORE DATA THAN AVAILABLE,  READ/AVAILABLE " << nitems << "/" << istream->nitems() );
               nitems = istream->nitems();
	  }
	  istream->consume( nitems );
	  LOG_TRACE( <%=PREFIX%>_base, " CONSUME READ DATA  ITEMS/REMAIN " << nitems << "/" << istream->nitems());
	}

      }
      gr_sptr->reset_read_index();
    }

    // check for not enough data return
    if ( nout == -1 ) {

      // check for  end of stream
      istream = istreams.begin();
      for ( ; istream != istreams.end() ; istream++) if ( istream->eos() ) eos=true;

      if ( eos ) {
        LOG_TRACE(  <%=PREFIX%>_base, "EOS SEEN, SENDING DOWNSTREAM " );
	_forecastAndProcess( eos, istreams, ostreams);
      }

      exitServiceFunction = true;
    }

  }

  if ( eos ) {

    istream = istreams.begin();
    for ( ; istream != istreams.end() ; istream++ ) {
        int idx=std::distance( istreams.begin(), istream );
        LOG_DEBUG( <%=PREFIX%>_base, " CLOSING INPUT STREAM IDX:" << idx );
        istream->close();
    }

    // close remaining output streams
    ostream = ostreams.begin();
    for ( ; eos && ostream != ostreams.end(); ostream++ ) {
        int idx=std::distance( ostreams.begin(), ostream );
        LOG_DEBUG( <%=PREFIX%>_base, " CLOSING OUTPUT STREAM IDX:" << idx );
        ostream->close();
    }

  }

  //
  // set the read pointers of the GNU Radio Block to start at the beginning of the 
  // supplied buffers
  //
  gr_sptr->reset_read_index();

  LOG_TRACE( <%=PREFIX%>_base, " END OF TRANSFORM SERVICE FUNCTION....." << noutput_items );

  if ( nout == -1 && eos == false )
    return NOOP;    
  else
    return NORMAL;

}


template <  typename IN_PORT_TYPE, typename OUT_PORT_TYPE > int <%=PREFIX%>_base::_forecastAndProcess( bool &eos, typename  std::vector< gr_istream< IN_PORT_TYPE > > &istreams ,
											typename  std::vector< gr_ostream< OUT_PORT_TYPE > > &ostreams  )
{
  typedef typename std::vector< gr_istream< IN_PORT_TYPE > >   _IStreamList;
  typedef typename std::vector< gr_ostream< OUT_PORT_TYPE > >  _OStreamList;

  typename _OStreamList::iterator ostream;
  typename _IStreamList::iterator istream = istreams.begin();
  int nout = 0;
  bool dataReady = false;
  if ( !eos ) {
    uint64_t max_items_avail = 0;
    for ( int idx=0 ; istream != istreams.end() && serviceThread->threadRunning() ; idx++, istream++ ) {
      LOG_TRACE(  <%=PREFIX%>_base, "GET MAX ITEMS: STREAM:"<< idx << " NITEMS/SCALARS:" << istream->nitems() << "/" << istream->_data.size() );
      max_items_avail = std::max( istream->nitems(), max_items_avail );
    }

    if ( max_items_avail == 0  ) {
       LOG_TRACE( <%=PREFIX%>_base, "DATA CHECK - MAX ITEMS  NOUTPUT/MAX_ITEMS:" <<   noutput_items << "/" << max_items_avail);
       return -1;
    }

    //
    // calc number of output elements based on input items available
    //
    noutput_items = 0;
    if ( !gr_sptr->fixed_rate() )  {
      noutput_items = round_down((int32_t) (max_items_avail * gr_sptr->relative_rate()), gr_sptr->output_multiple());
      LOG_TRACE( <%=PREFIX%>_base, " VARIABLE FORECAST NOUTPUT == " << noutput_items );
    }   
    else {
      istream = istreams.begin();
      for ( int i=0; istream != istreams.end(); i++, istream++ ) {
        if ( gr_sptr->fixed_rate() ) {
          int t_noutput_items = gr_sptr->fixed_rate_ninput_to_noutput( istream->nitems() );
	  if ( gr_sptr->output_multiple_set() ) {
	    t_noutput_items = round_up(t_noutput_items, gr_sptr->output_multiple());
	  }
	  if ( t_noutput_items > 0 ) {
	    if ( noutput_items == 0 ) noutput_items = t_noutput_items;
	    if ( t_noutput_items <= noutput_items ) noutput_items = t_noutput_items;
	  }
        }
      }
      LOG_TRACE( <%=PREFIX%>_base,  " FIXED FORECAST NOUTPUT/output_multiple == " << noutput_items  << "/" << gr_sptr->output_multiple());
    }

    //
    // ask the block how much input they need to produce noutput_items...
    // if enough data is available to process then set the dataReady flag
    //
    int32_t  outMultiple = gr_sptr->output_multiple();
    while ( !dataReady && noutput_items >= outMultiple  ) {
      //
      // ask the block how much input they need to produce noutput_items...
      //
      gr_sptr->forecast(noutput_items, _ninput_items_required);

      LOG_TRACE( <%=PREFIX%>_base, "--> FORECAST IN/OUT " << _ninput_items_required[0]  << "/" << noutput_items  );

      istream = istreams.begin();
      uint32_t dr_cnt=0;
      for ( int idx=0 ; noutput_items > 0 && istream != istreams.end(); idx++, istream++ ) {
	// check if buffer has enough elements
	_input_ready[idx] = false;
	if ( istream->nitems() >= (uint64_t)_ninput_items_required[idx] ) {
	  _input_ready[idx] = true;
	  dr_cnt++;
	}
	LOG_TRACE( <%=PREFIX%>_base, "ISTREAM DATACHECK NELMS/NITEMS/REQ/READY:" <<   istream->nelems() << "/" << istream->nitems() << "/" << _ninput_items_required[idx] << "/" << _input_ready[idx]);
      }
    
      if ( dr_cnt < istreams.size() ) {
        if ( outMultiple > 1 )
       	  noutput_items -= outMultiple;
        else
          noutput_items /= 2;
      }
      else {
        dataReady = true;
      }
      LOG_TRACE( <%=PREFIX%>_base, " TRIM FORECAST NOUTPUT/READY " << noutput_items << "/" << dataReady );
    }

    // check if data is ready...
    if ( !dataReady ) {
      LOG_TRACE( <%=PREFIX%>_base, "DATA CHECK - NOT ENOUGH DATA  AVAIL/REQ:" <<   _istreams[0].nitems() << "/" << _ninput_items_required[0] );
      return -1;	 
    }

    // reset looping variables
    int  ritems = 0;
    int  nitems = 0;

    // reset caching vectors
    _output_items.clear();
    _input_items.clear();
    _ninput_items.clear();
    istream = istreams.begin();
    for ( int idx=0 ; istream != istreams.end(); idx++, istream++ ) {

      // check if the stream is ready
      if ( !_input_ready[idx] ) continue;
      
      // get number of items remaining
      try {
        ritems = gr_sptr->nitems_read( idx );
      }
      catch(...){
        // something bad has happened, we are missing an input stream
	LOG_ERROR( <%=PREFIX%>_base, "MISSING INPUT STREAM FOR GR BLOCK, STREAM ID:" <<   istream->streamID );
        return -2;
      } 
    
      nitems = istream->nitems() - ritems;
      LOG_TRACE( <%=PREFIX%>_base,  " ISTREAM: IDX:" << idx  << " ITEMS AVAIL/READ/REQ " << nitems << "/" 
		 << ritems << "/" << _ninput_items_required[idx] );
      if ( nitems >= _ninput_items_required[idx] && nitems > 0 ) {
	//remove eos checks ...if ( nitems < _ninput_items_required[idx] ) nitems=0;
        _ninput_items.push_back( nitems );
	_input_items.push_back( (const void *) (istream->read_pointer(ritems)) );
      }
    }

    //
    // setup output buffer vector based on noutput..
    //
    ostream = ostreams.begin();
    for( ; ostream != ostreams.end(); ostream++ ) {
      ostream->resize(noutput_items);
      _output_items.push_back((void*)(ostream->write_pointer()) );
    }

    nout=0;
    if ( _input_items.size() != 0 && serviceThread->threadRunning() ) {
      LOG_TRACE( <%=PREFIX%>_base, " CALLING WORK.....N_OUT:" << noutput_items << " N_IN:" << nitems << " ISTREAMS:" << _input_items.size() << " OSTREAMS:" << _output_items.size());
      nout = gr_sptr->general_work( noutput_items, _ninput_items, _input_items, _output_items);
      LOG_TRACE( <%=PREFIX%>_base, "RETURN  WORK ..... N_OUT:" << nout);
    }

    // check for stop condition from work method
    if ( nout < gr_block::WORK_DONE ) {
      LOG_WARN( <%=PREFIX%>_base, "WORK RETURNED STOP CONDITION..." << nout );
      nout=0;
      eos = true;
    }
  }

  if (nout != 0 or eos ) {

    noutput_items = nout;
    LOG_TRACE( <%=PREFIX%>_base, " WORK RETURNED: NOUT : " << nout << " EOS:" << eos);
    ostream = ostreams.begin();
    typename IN_PORT_TYPE::dataTransfer *pkt=NULL;
    for ( int idx=0 ; ostream != ostreams.end(); idx++, ostream++ ) {

      pkt=NULL;
      int inputIdx = idx;
      if ( (size_t)(inputIdx) >= istreams.size() ) {
	for ( inputIdx= istreams.size()-1; inputIdx > -1; inputIdx--) {
	  if ( istreams[inputIdx].pkt != NULL ) {
	    pkt = istreams[inputIdx].pkt;
	    break;
	  }
	}
      }
      else {
	pkt = istreams[inputIdx].pkt;
      }

      LOG_TRACE( <%=PREFIX%>_base,  "PUSHING DATA   ITEMS/STREAM_ID " << ostream->nitems() << "/" << ostream->streamID );    
      if ( _maintainTimeStamp ) {

	// set time stamp for output samples based on input time stamp
	if ( ostream->nelems() == 0 )  {
#ifdef TEST_TIME_STAMP
	  LOG_DEBUG(  <%=PREFIX%>_base, "SEED - TS SRI:  xdelta:" << std::setprecision(12) << ostream->sri.xdelta );
	  LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM WRITE:   maint:" << _maintainTimeStamp );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                  mode:" <<  ostream->tstamp.tcmode );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                status:" <<  ostream->tstamp.tcstatus );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                offset:" <<  ostream->tstamp.toff );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                 whole:" <<  std::setprecision(10) << ostream->tstamp.twsec );
	  LOG_DEBUG(  <%=PREFIX%>_base, "SEED - TS         frac:" <<  std::setprecision(12) << ostream->tstamp.tfsec );
#endif
	  ostream->setTimeStamp( pkt->T, _maintainTimeStamp );
	}

	// write out samples, and set next time stamp based on xdelta and  noutput_items
	ostream->write ( noutput_items, eos );

      }
      else {
	// use incoming packet's time stamp to forward
	if ( pkt ) {
#ifdef TEST_TIME_STAMP
	  LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM  SRI:  items/xdelta:" << noutput_items << "/" << std::setprecision(12) << ostream->sri.xdelta );
	  LOG_DEBUG(  <%=PREFIX%>_base, "PKT - TS         maint:" << _maintainTimeStamp );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                  mode:" <<  pkt->T.tcmode );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                status:" <<  pkt->T.tcstatus );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                offset:" <<  pkt->T.toff );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                 whole:" <<  std::setprecision(10) << pkt->T.twsec );
	  LOG_DEBUG(  <%=PREFIX%>_base, "PKT - TS          frac:" <<  std::setprecision(12) << pkt->T.tfsec );
#endif
	  ostream->write( noutput_items, eos, pkt->T  );	   
	}
	else {
#ifdef TEST_TIME_STAMP
	  LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM  SRI:  items/xdelta:" << noutput_items << "/" << std::setprecision(12) << ostream->sri.xdelta );
	  LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM TOD      maint:" << _maintainTimeStamp );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                  mode:" <<  ostream->tstamp.tcmode );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                status:" <<  ostream->tstamp.tcstatus );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                offset:" <<  ostream->tstamp.toff );
	  LOG_DEBUG(  <%=PREFIX%>_base, "                 whole:" <<  std::setprecision(10) << ostream->tstamp.twsec );
	  LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM TOD       frac:" <<  std::setprecision(12) << ostream->tstamp.tfsec );
#endif
	  // use time of day as time stamp
	  ostream->write( noutput_items, eos,  _maintainTimeStamp );	   
	}
      }

    } // for ostreams

  }

  return nout;
     
}



<%
   // End of Template for Data Transformer Pattern 
  } 
%>


<%
 
   /////////////////////////////////////
   //  DATA GENERATOR TEMPLATE Service Function for GR_BLOCK PATTERN
   /////////////////////////////////////
  if ( inputType.equals("") && !outputType.equals("") ) {

%>

/**
  DATA GENERATOR TEMPLATE Service Function for GR_BLOCK PATTERN
*/

template < typename OUT_PORT_TYPE > int <%=PREFIX%>_base::_generatorServiceFunction( typename  std::vector< gr_ostream< OUT_PORT_TYPE > > &ostreams ) 
{

  typedef typename std::vector< gr_ostream< OUT_PORT_TYPE > >  _OStreamList;

  boost::mutex::scoped_lock lock(serviceThreadLock);

  if ( validGRBlock() == false ) {

    // create our processing block, and setup  property notifiers
    createBlock();

    LOG_DEBUG( <%=PREFIX%>_base, "FINISHED BUILDING  GNU RADIO BLOCK");
  }


  if ( !validGRBlock() || ostreams.size() == 0  ) {
    LOG_WARN( <%=PREFIX%>_base, "NO OUTPUT STREAMS DEFINED FOR GNU RADIO BLOCK..." );
    return NOOP;
  }

  _ninput_items_required.resize( 0 );
  _ninput_items.resize( 0 );
  _input_items.resize(0);
  _output_items.resize( 0 );

  typename _OStreamList::iterator  ostream;
  noutput_items = gr_pagesize();

  // find transfer length for this block... 
  //   Might want to add per port property and save it off when setupIOMappings is called
  if ( propTable.find("transfer_size") != propTable.end()) {
    CORBA::Any transfer_any;
    CORBA::Long transfer;

    propTable["transfer_size"]->getValue(transfer_any);
    try {
      transfer_any >>= transfer;
      noutput_items = transfer;
    }
    catch(...)
    {}
  }

  gr_sptr->forecast(noutput_items, _ninput_items_required);

  LOG_TRACE(  <%=PREFIX%>_base, " FORECAST == " << noutput_items );

  ostream = ostreams.begin();
  for( ; ostream != ostreams.end(); ostream++ ) {
    // push ostream's buffer address onto list of output buffers
    ostream->resize(noutput_items);
    _output_items.push_back((void*)(ostream->write_pointer()) );
  }

  // call the work function
  int numOut=0;
  numOut = gr_sptr->general_work( noutput_items, _ninput_items, _input_items, _output_items);

  bool eos = false;
  // check for stop condition from work method
  if ( numOut == gr_block::WORK_DONE ) {
    numOut = 0;
    eos=true;
  } else {
    sentEOS = false;
  }

  if (numOut != 0 or (eos and !sentEOS)){

    // write out all the data   
    ostream = ostreams.begin();
    for( ; ostream != ostreams.end(); ostream++ ) {
      LOG_TRACE( <%=PREFIX%>_base, "PUSHING DATA   NOUT/NITEMS/OITEMS/STREAM_ID " << numOut << "/" << ostream->nitems()  << "/" << ostream->oitems() << "/" << ostream->streamID );
#ifdef TEST_TIME_STAMP
      LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM SRI:    xdelta:" << std::setprecision(12) << ostream->sri.xdelta );
      LOG_DEBUG(  <%=PREFIX%>_base, "OSTREAM WRITE:   maint:" << _maintainTimeStamp );
      LOG_DEBUG(  <%=PREFIX%>_base, "                  mode:" <<  ostream->tstamp.tcmode );
      LOG_DEBUG(  <%=PREFIX%>_base, "                status:" <<  ostream->tstamp.tcstatus );
      LOG_DEBUG(  <%=PREFIX%>_base, "                offset:" <<  ostream->tstamp.toff );
      LOG_DEBUG(  <%=PREFIX%>_base, "                 whole:" <<  std::setprecision(10) << ostream->tstamp.twsec );
      LOG_DEBUG(  <%=PREFIX%>_base, "                  frac:" <<  std::setprecision(12) << ostream->tstamp.tfsec );
#endif
      ostream->write( numOut, eos, _maintainTimeStamp );

   }
   if (eos)
     sentEOS = true;

   // close stream and reset counters  
   ostream = ostreams.begin(); 
   for( ; eos && ostream != ostreams.end(); ostream++ )  ostream->close();

   if (eos)
     return NOOP;

  }

  return NORMAL;
}

<%
   // End of Template for Data Generator Pattern 
  } 
%>



